# 浏览器技术持久化

- localStorage
- IndexedDB
- Dexie.js



## localStorage

在 Electron 中，如果你打开了多个 BrowserWindow 的实例，那么它们默认情况下会共享同一个 localStorage 空间。

另外，关于多个窗口是否共享 localStorage 这一点，虽然默认是多窗口共享，但是是可以进行配置的。

例如，在创建窗口二的时候，可以添加如下的配置：

```js
const secondWin = new BrowserWindow({
  width: 800,
  height: 600,
  webPreferences: {
    nodeIntegration: true,
    contextIsolation: false,
    partition: "persist:myCustomPartition",
  },
});
```

- partition：用于定义该窗口数据存储的独立性和持久性
  - persist：这是一个前缀，该前缀表明这是一个持久性的会话
  - myCustomPartition：这个标识符代表该会话的唯一名称。这里就是通过不同的 partition 名称，给应用中的不同窗口创建了隔离的存储空间。



## IndexedDB

IndexedDB 是一种低级的 API，用于在用户的浏览器中存储大量的结构化数据。这个 API 使用索引来实现对数据的高性能搜索。它允许你创建、读取、导航和写入客户端数据库中的数据。IndexedDB 对于需要在客户端存储大量数据或无需持续联网的应用程序特别有用。

### 基础介绍

- **数据库**：IndexedDB 创建的是一个数据库，你可以在其中存储键值对。
- **对象仓库**：这是数据库中的一个“表”，用于存储数据对象。
- **事务**：数据的读写操作是通过事务进行的。
- **键**：数据存储的标识。
- **索引**：用于高效搜索数据。

### 打开数据库

在使用 IndexedDB 之前，需要打开一个数据库。如果指定的数据库不存在，浏览器会创建它。

```javascript
let db;
const request = indexedDB.open("MyTestDatabase", 1);

request.onerror = function(event) {
  // 错误处理
  console.log("Database error: " + event.target.errorCode);
};

request.onsuccess = function(event) {
  db = event.target.result;
};
```

### 创建对象仓库

对象仓库类似于 SQL 数据库中的表。以下是在数据库的升级过程中创建对象仓库的示例：

```javascript
request.onupgradeneeded = function(event) {
  const db = event.target.result;

  // 创建一个对象仓库来存储我们的数据。我们将使用 "id" 作为键路径，因为我们假设它是唯一的。
  const objectStore = db.createObjectStore("name", { keyPath: "id" });

  // 创建一个索引来通过 name 进行搜索。
  objectStore.createIndex("name", "name", { unique: false });
};
```

### 添加数据

一旦有了对象仓库，就可以往里面添加数据了。这需要在一个事务中完成。

```javascript
function addData() {
  const transaction = db.transaction(["name"], "readwrite");
  const objectStore = transaction.objectStore("name");
  
  const data = {id: "1", name: "Zhang San"};
  const request = objectStore.add(data);

  request.onsuccess = function(event) {
    console.log("数据添加成功");
  };

  request.onerror = function(event) {
    console.log("数据添加失败");
  };
}
```

### 读取数据

从对象仓库中读取数据也很简单：

```javascript
function readData() {
  const transaction = db.transaction(["name"]);
  const objectStore = transaction.objectStore("name");
  const request = objectStore.get("1"); // 使用 id 读取数据

  request.onerror = function(event) {
    console.log("事务失败");
  };

  request.onsuccess = function(event) {
    if (request.result) {
      console.log("Name: " + request.result.name);
    } else {
      console.log("未找到数据");
    }
  };
}
```

### 更新数据

更新数据与添加数据类似，但通常会先读取现有数据，然后进行修改。

```javascript
function updateData() {
  const transaction = db.transaction(["name"], "readwrite");
  const objectStore = transaction.objectStore("name");
  const request = objectStore.get("1");

  request.onsuccess = function(event) {
    const data = event.target.result;
    data.name = "Li Si"; // 修改名称

    const requestUpdate = objectStore.put(data);
    requestUpdate.onerror = function(event) {
      console.log("更新失败");
    };
    requestUpdate.onsuccess = function(event) {
      console.log("更新成功");
    };
  };
}
```

### 删除数据

删除数据也很直接：

```javascript
function deleteData() {
  const request = db.transaction(["name"], "readwrite")
    .objectStore("name")
    .delete("1");

  request.onsuccess = function(event) {
    console.log("数据删除成功");
  };
}
```



以上就是 IndexedDB 的基本用法。通过这些基本操作，可以在前端应用中实现复杂的数据存储需求。不过，记得 IndexedDB 的操作都是异步的，所以你可能需要管理好回调或者使用`async/await`来处理这些异步操作。



## Dexie.js

除了使用浏览器原生的 IndexedDB 以外，我们还可以使用 Dexie.js，该第三方库提供了<u>更简洁、更易用</u>的 API。

**IndexedDB**

1. **原生 Web API**：IndexedDB 是一个低级的 API，直接内置于现代浏览器中，用于在客户端存储大量结构化数据。
2. **复杂性**：直接使用 IndexedDB 可能相当复杂，主要是因为它的异步性质和繁琐的错误处理。它的 API 设计更偏向于底层，提供了大量的灵活性，但也使得简单操作变得复杂。
3. **事务管理**：IndexedDB 需要显式地处理事务。事务、对象存储、索引等需要仔细管理和协调。
4. **无包装器**：直接使用 IndexedDB 意味着编写更多的引导和设置代码，例如处理数据库的版本升级逻辑。

**Dexie.js**

1. **封装库**：Dexie.js 是一个对 IndexedDB 进行封装的库，提供了一个简单、更易于理解和使用的 API。
2. **简化的操作**：通过 Dexie.js，复杂的 IndexedDB 操作变得更简单。例如，它简化了异步操作的处理，使得使用 promises 和 async/await 变得直观。
3. **错误处理**：Dexie.js 提供了更加友好和简洁的错误处理方式。
4. **强化的功能**：Dexie.js 增加了一些额外的功能，如简化的索引查询和批量操作。
5. **事务管理**：Dexie.js 简化了事务管理。你仍然需要理解 IndexedDB 的事务概念，但 Dexie.js 提供了更简单的方法来处理它们。
6. **易于升级**：在 Dexie.js 中，处理数据库的版本升级更加简单和直观。

**Dexie.js 的优势**

- **更简洁的代码**：使用 Dexie.js 可以写出更清晰、更简洁的代码，尤其是在处理复杂查询和大量的异步操作时。
- **易于维护**：由于 API 更加简单，维护和更新使用 Dexie.js 编写的代码通常比直接使用 IndexedDB 更容易。
- **更好的错误处理**：Dexie.js 提供了更友好的错误处理机制，有助于更容易地诊断问题。
- **社区支持**：Dexie.js 拥有一个活跃的社区，提供了丰富的文档和社区支持。

下面简单介绍一下它的基本语法：

```js
let db = new Dexie("testDb");
db.version(1).stores({ articles: "id", settings: "id"});
```

第一行创建一个名为 *testDb* 的 *IndexedDB* 数据库。第二行中的 *db.version(1)* 表示数据库的版本。

在 *IndexedDB* 中，有版本的概念，例如假设现在的应用的数据库版本号为 *1*（默认值也是 *1*），新版本应用希望更新数据结构，可以把数据库版本号设置为 *2*。当用户打开应用访问数据时，会触发 *IndexedDB* 的 *upgradeneeded* 事件，我们可以在此事件中完成数据的迁移工作。

在 *Dexie.js* 中，对 *IndexedDB* 的版本 *API* 进行了封装，所以在上面的代码中，我们使用 *db.version* 方法获得当前版本的实例，然后调用实例方法 *stores*，并传入数据结构对象。

数据结构对象相当于传统数据库的表，与传统数据库不同的是，我们不必为数据结构对象指定每一个字段的字段名，此处我们为 *IndexedDB* 添加了两个表 *articles* 和 *settings*，它们都有一个必备字段 *id*，其他字段可以在写入数据时临时决定。

将来如果版本更新，数据库版本号变为 *2* 时，数据库增加了一张表 *users*，代码如下：

```js
db.version(2).stores({ articles: "id", settings: "id", users: "id"});
```

此时 *Dexie.js* 会为我们进行相应的处理，在增加新的表的同时，原有表以及表里面的数据不变。这为我们从容地控制客户端数据库版本提供了强有力的支撑。

下面来看一下使用 *Dexie.js* 进行常用数据操作的代码：

```js
// 增加数据
await db.articles.add({ id: 0, title: 'test'});

// 查询数据
await db.articles.filter(article => article.title === 'test');

// 修改数据
await db.articles.put({ id: 0, title: 'testtest'});

// 删除数据
await db.articles.delete(id);

// 排序数据
await db.articles.orderBy('title');
```

注意，上面的代码中使用到了 *await* 关键字，所以使用的时候，应该放在 *async* 标记的函数里面才能正常执行。

更多有关 *Dexie.js* 的使用，可以参阅官网：*https://dexie.org/*
