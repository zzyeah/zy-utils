# 浏览器技术持久化

- localStorage
- IndexedDB



## localStorage

在 Electron 中，如果你打开了多个 BrowserWindow 的实例，那么它们默认情况下会共享同一个 localStorage 空间。

另外，关于多个窗口是否共享 localStorage 这一点，虽然默认是多窗口共享，但是是可以进行配置的。

例如，在创建窗口二的时候，可以添加如下的配置：

```js
const secondWin = new BrowserWindow({
  width: 800,
  height: 600,
  webPreferences: {
    nodeIntegration: true,
    contextIsolation: false,
    partition: "persist:myCustomPartition",
  },
});
```

- partition：用于定义该窗口数据存储的独立性和持久性
  - persist：这是一个前缀，该前缀表明这是一个持久性的会话
  - myCustomPartition：这个标识符代表该会话的唯一名称。这里就是通过不同的 partition 名称，给应用中的不同窗口创建了隔离的存储空间。



## IndexedDB

IndexedDB 是一种低级的 API，用于在用户的浏览器中存储大量的结构化数据。这个 API 使用索引来实现对数据的高性能搜索。它允许你创建、读取、导航和写入客户端数据库中的数据。IndexedDB 对于需要在客户端存储大量数据或无需持续联网的应用程序特别有用。

### 基础介绍

- **数据库**：IndexedDB 创建的是一个数据库，你可以在其中存储键值对。
- **对象仓库**：这是数据库中的一个“表”，用于存储数据对象。
- **事务**：数据的读写操作是通过事务进行的。
- **键**：数据存储的标识。
- **索引**：用于高效搜索数据。

### 打开数据库

在使用 IndexedDB 之前，需要打开一个数据库。如果指定的数据库不存在，浏览器会创建它。

```javascript
let db;
const request = indexedDB.open("MyTestDatabase", 1);

request.onerror = function(event) {
  // 错误处理
  console.log("Database error: " + event.target.errorCode);
};

request.onsuccess = function(event) {
  db = event.target.result;
};
```

### 创建对象仓库

对象仓库类似于 SQL 数据库中的表。以下是在数据库的升级过程中创建对象仓库的示例：

```javascript
request.onupgradeneeded = function(event) {
  const db = event.target.result;

  // 创建一个对象仓库来存储我们的数据。我们将使用 "id" 作为键路径，因为我们假设它是唯一的。
  const objectStore = db.createObjectStore("name", { keyPath: "id" });

  // 创建一个索引来通过 name 进行搜索。
  objectStore.createIndex("name", "name", { unique: false });
};
```

### 添加数据

一旦有了对象仓库，就可以往里面添加数据了。这需要在一个事务中完成。

```javascript
function addData() {
  const transaction = db.transaction(["name"], "readwrite");
  const objectStore = transaction.objectStore("name");
  
  const data = {id: "1", name: "Zhang San"};
  const request = objectStore.add(data);

  request.onsuccess = function(event) {
    console.log("数据添加成功");
  };

  request.onerror = function(event) {
    console.log("数据添加失败");
  };
}
```

### 读取数据

从对象仓库中读取数据也很简单：

```javascript
function readData() {
  const transaction = db.transaction(["name"]);
  const objectStore = transaction.objectStore("name");
  const request = objectStore.get("1"); // 使用 id 读取数据

  request.onerror = function(event) {
    console.log("事务失败");
  };

  request.onsuccess = function(event) {
    if (request.result) {
      console.log("Name: " + request.result.name);
    } else {
      console.log("未找到数据");
    }
  };
}
```

### 更新数据

更新数据与添加数据类似，但通常会先读取现有数据，然后进行修改。

```javascript
function updateData() {
  const transaction = db.transaction(["name"], "readwrite");
  const objectStore = transaction.objectStore("name");
  const request = objectStore.get("1");

  request.onsuccess = function(event) {
    const data = event.target.result;
    data.name = "Li Si"; // 修改名称

    const requestUpdate = objectStore.put(data);
    requestUpdate.onerror = function(event) {
      console.log("更新失败");
    };
    requestUpdate.onsuccess = function(event) {
      console.log("更新成功");
    };
  };
}
```

### 删除数据

删除数据也很直接：

```javascript
function deleteData() {
  const request = db.transaction(["name"], "readwrite")
    .objectStore("name")
    .delete("1");

  request.onsuccess = function(event) {
    console.log("数据删除成功");
  };
}
```



以上就是 IndexedDB 的基本用法。通过这些基本操作，可以在前端应用中实现复杂的数据存储需求。不过，记得 IndexedDB 的操作都是异步的，所以你可能需要管理好回调或者使用`async/await`来处理这些异步操作。
